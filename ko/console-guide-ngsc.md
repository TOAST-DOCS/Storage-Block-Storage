## Storage > Block Storage > 콘솔 사용 가이드

## 블록 스토리지 생성

인스턴스에 연결할 블록 스토리지를 생성합니다.

블록 스토리지는 아무 데이터도 들어 있지 않은 빈 블록 스토리지로 만들 수도 있으며, 기존 블록 스토리지의 스냅숏으로도 생성할 수 있습니다.

빈 블록 스토리지를 생성하려면 **Block Storage 소스**를 **소스 없음, 빈 Block Storage**로 선택합니다. 빈 블록 스토리지는 인스턴스에 연결 후, 파티션을 나누고 포맷을 한 후에 사용해야 합니다. 블록 스토리지 사용법은 [블록 스토리지 개요 > 빈 블록 스토리지 사용](/Storage/Block%20Storage/ko/overview-ngsc/#_1)을 참고합니다. 빈 블록 스토리지가 위치할 가용성 영역(availability zone)은 생성할 블록 스토리지를 연결할 인스턴스가 있는 가용성 영역을 사용합니다. 블록 스토리지 타입은 필요한 I/O 성능에 따라 **HDD**나 **SSD** 중 하나를 선택합니다.

블록 스토리지의 스냅숏으로부터 블록 스토리지를 생성할 수도 있습니다. 스냅숏으로부터 블록 스토리지를 생성하는 경우, 블록 스토리지의 크기는 스냅숏의 크기와 같거나 더 커야 합니다. 크기를 더 크게 설정한다면 고객이 직접 기존 블록 스토리지의 파티션을 조정하거나 새로운 파티션을 추가하여 늘어난 저장 공간을 사용해야 합니다.

## 블록 스토리지 삭제

블록 스토리지를 삭제하기 전에 다음 사항을 확인합니다.

* 인스턴스에 연결되어 있는 블록 스토리지는 삭제할 수 없습니다. 먼저 연결을 해제합니다.
* 스냅숏을 가지고 있는 블록 스토리지는 삭제할 수 없습니다. 블록 스토리지의 스냅숏을 모두 삭제합니다.

한번 삭제된 블록 스토리지는 다시 복구할 수 없습니다.

## 블록 스토리지 크기 변경

블록 스토리지의 크기를 변경할 수 있습니다. 블록 스토리지의 크기는 줄일 수 없으며 늘릴 수만 있습니다.

인스턴스에 연결된 블록 스토리지의 경우 아래를 참고하여 파티션과 파일 시스템을 확장하여야 합니다.

### Linux 인스턴스

#### 파티션 확장

1. 블록 스토리지의 파티션을 확인합니다.

        # sudo lsblk

    파티션이 존재하지 않는다면 아래의 `파일 시스템 확장`으로 이동합니다.

2. 파티션을 확장합니다.

    예를 들어 `/dev/vda` 디바이스의 `1번 파티션`을 확장하려는 경우 아래와 같습니다.

        # sudo growpart /dev/vda 1

3. 확장된 파티션을 확인합니다.

        # sudo lsblk

#### 파일 시스템 확장

1. 확장할 파일 시스템의 유형을 확인합니다.

        # df -hT

2. 파일 시스템의 유형에 따라 아래의 명령어를 입력해 확장합니다.
 
    **[XFS 파일 시스템]** 예를 들어 `/`에 마운트된 파일 시스템을 확장하려는 경우 아래와 같습니다.

        # sudo xfs_growfs -d /

    **[Ext4 파일 시스템]** 예를 들어 `/dev/vda` 디바이스의 파일 시스템을 확장하려는 경우 아래와 같습니다.

        # sudo resize2fs /dev/vda    

3. 확장된 파일 시스템을 확인합니다.

        # df -hT

   
### Windows 인스턴스

1. **Run**에서 **diskmgmt.msc**를 입력하고 **OK**를 클릭해 디스크 관리 유틸리티를 실행합니다.
![image.png](https://static.toastoven.net/prod_infrastructure/block_storage/windows_volume_extend_01.png)
2. 블록 스토리지에 추가된 크기만큼 **Unallocated** 상태로 표시됩니다. 확장된 드라이브를 마우스 오른쪽으로 클릭한 뒤 **Extend Volume...**을 클릭해 볼륨 확장 마법사를 실행합니다.
![image.png](https://static.toastoven.net/prod_infrastructure/block_storage/windows_volume_extend_02.png)
3. 볼륨 확장 마법사에서 **Next**를 클릭합니다. **Select the amount of space in MB**에 확장할 메가바이트 수를 입력합니다.

    입력 가능한 최대 메가바이트 수는 **Maximum available space in MB**를 참고합니다. 다시 **Next**를 눌러 볼륨 확장 마법사를 완료합니다.
![image.png](https://static.toastoven.net/prod_infrastructure/block_storage/windows_volume_extend_03.png)
4. **This PC**에서 확장된 드라이브를 확인합니다.
![image.png](https://static.toastoven.net/prod_infrastructure/block_storage/windows_volume_extend_04.png)

## 연결 관리

### 블록 스토리지 연결

인스턴스에 블록 스토리지를 연결합니다. 인스턴스가 실행 중일 때에도 연결할 수 있습니다. 블록 스토리지는 같은 가용성 영역에 있는 인스턴스에만 연결할 수 있습니다. 블록 스토리지를 생성할 때 연결할 인스턴스와 동일한 가용성 영역에서 블록 스토리지를 만들도록 합니다.

빈 블록 스토리지를 연결하면 인스턴스에서 파티션을 나누고 포맷한 후에 사용해야 합니다. 포맷이 된 블록 스토리지는 마운트하여 사용합니다. 스냅숏으로 만든 블록 스토리지도 고객이 직접 인스턴스 내에서 마운트해야 사용할 수 있습니다.

> [참고]
> 운영체제의 기능에 따라 자동으로 마운트되어 별도의 마운트 과정이 필요 없을 수도 있습니다.

### 블록 스토리지 연결 해제

인스턴스에서 필요 없는 블록 스토리지를 연결 해제합니다. 단, 루트 블록 스토리지는 인스턴스에서 연결 해제할 수 없습니다.

인스턴스가 실행 중인 상태에서도 블록 스토리지 연결을 해제할 수 있습니다. 단, 먼저 인스턴스에서 블록 스토리지 마운트를 해제하고 콘솔에서 블록 스토리지 연결을 해제해야 합니다. 블록 스토리지가 마운트된 상태에서 연결을 해제하면 다음과 같은 문제가 발생합니다.

1. 블록 스토리지 데이터가 손상돼 데이터가 유실될 수 있습니다.
2. 블록 스토리지를 새로 추가하면 콘솔의 블록 스토리지 이름과 인스턴스의 블록 스토리지 이름이 다르게 보입니다. 콘솔과 인스턴스에서 동일한 블록 스토리지 이름이 나타나게 하려면 인스턴스를 재시작해야 합니다.

**Linux 인스턴스**

	# umount <마운트 포인트>

**Windows 인스턴스**

**디스크 관리**에서 해당 디스크를 **오프라인**으로 만든 후 연결 해제합니다.

## 스냅숏 생성

블록 스토리지의 읽기 전용 복사본을 만듭니다. 블록 스토리지가 인스턴스에 연결되어 있는 상태에서도 블록 스토리지 스냅숏을 생성할 수 있지만 데이터의 정합성과 안정성을 보장하려면 인스턴스에서 연결을 해제하고 블록 스토리지 스냅숏을 생성하기를 권장합니다.

## 문제 해결 가이드

### 의도하지 않은 블록 스토리지로 부팅되는 문제

인스턴스에 추가로 연결한 블록 스토리지가 `/`에 마운트된 상태로 인스턴스가 부팅될 수 있습니다. 이 현상은 주로 인스턴스의 OS 이미지로 생성된 블록 스토리지를 다른 인스턴스에 추가로 연결할 때 발생합니다.

Linux는 부팅 시에 `/etc/fstab`을 통해 `/`에 마운트 할 블록 스토리지를 결정합니다. NHN Cloud에서 사용하는 OS 이미지의 경우 파일 시스템 UUID를 기준으로 마운트 할 블록 스토리지를 결정하는데, 파일 시스템 UUID 값이 같은 블록 스토리지가 연결되면 의도하지 않은 블록 스토리지가 `/`에 마운트 될 수 있습니다.

```console
# cat /etc/fstab
...
UUID=6cd50e51-cfc6-40b9-9ec5-f32fa2e4ff02 /                       xfs     defaults        0 0
```

`blkid` 명령어를 통해 블록 스토리지의 파일 시스템 UUID를 확인할 수 있습니다.

```console
# blkid
/dev/vda1: UUID="6cd50e51-cfc6-40b9-9ec5-f32fa2e4ff02" TYPE="xfs"
/dev/vdb1: UUID="6cd50e51-cfc6-40b9-9ec5-f32fa2e4ff02" TYPE="xfs"
```

위와 같이 추가로 연결된 블록 스토리지의 파일 시스템 UUID가 동일하면, Linux 배포판 동작 방식에 따라 추가로 연결한 블록 스토리지가 `/`에 마운트 될 수 있습니다.

다음 절차를 따라 두 블록 스토리지의 파일 시스템 UUID를 다르게 하여 문제를 해결합니다.

1. 인스턴스를 중지한 후, 문제를 일으키는(즉, `/`로 잘못 마운트되던) [블록 스토리지의 연결을 해제](console-guide/#_5)합니다.

2. 인스턴스를 시작합니다.

3. 부팅이 완료되면 문제를 일으키는 [블록 스토리지를 다시 연결](console-guide/#_4)합니다.

4. 아래 명령어를 통해 문제를 일으키는 블록 스토리지의 파일 시스템 UUID를 교체합니다. 문제를 일으키는 블록 스토리지의 타입에 따라 아래 명령어를 실행합니다. 블록 스토리지의 타입은 `blkid` 명령어를 통해 확인할 수 있습니다.

	문제를 일으키는 블록 스토리지의 파일 시스템이 ext4일 경우,

	<pre><code class="language-console"># tune2fs -U random /dev/vdb1
	tune2fs 1.42.9 (28-Dec-2013)
	Setting the UUID on this filesystem could take some time.
	Proceed anyway (or wait 5 seconds to proceed) ? (y,N) y
	</code></pre>

	문제를 일으키는 블록 스토리지의 파일 시스템이 xfs일 경우,

	<pre><code class="language-console"># xfs_admin -U generate /dev/vdb1
	Clearing log and setting UUID
	writing all SBs
	new UUID = 0037c590-0545-4736-bcdc-d052681eb5f5
	</code></pre>

5. 파일 시스템 UUID가 바뀐 것을 확인합니다.

	<pre><code class="language-console"># blkid
	/dev/vda1: UUID="6cd50e51-cfc6-40b9-9ec5-f32fa2e4ff02" TYPE="xfs"
	/dev/vdb1: UUID="0037c590-0545-4736-bcdc-d052681eb5f5" TYPE="xfs"
	</code></pre>

### 블록 스토리지의 마운트에 실패하여 인스턴스가 동작하지 않는 문제

블록 스토리지를 추가할 때 `/etc/fstab`를 잘못 설정하였다면 부팅 과정에서 볼륨 마운트에 실패하고 인스턴스가 emergency mode로 진입할 수 있습니다.

이러한 상황을 방지하기 위하여 추가 블록 스토리지를 `/etc/fstab`에 등록할 경우에는 [블록 스토리지 마운트 가이드](/Storage/Block%20Storage/ko/overview-ngsc/#_4)에 따라 `nofail` 옵션을 사용하는 것을 권장합니다.

만약 `/etc/fstab`를 잘못 수정하여 인스턴스가 정상적으로 부팅되지 않는다면 고객 센터로 문의해 주시기 바랍니다.
